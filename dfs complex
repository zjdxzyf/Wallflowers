/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2018-2019. All rights reserved.
 * Description: OJ
 * Author: zhuyifan
 * Create: 2019-9-10
 */


#include <iostream>
#include <vector>
#include <climits>
#include <cmath>
#include <set>

using namespace std;
//definition of struct node and mapDef
int n;
int num;
int flag;
bool equalFlag = false;

struct node {
    vector<int> dest;
    vector<int> d;
};

struct mapDef {
    node *graph = new node[num];
    int begin;
    int end;
    vector<int> mustGo;
    vector<int> visited;
    vector<int> D = vector<int>(num, INT_MAX);
};

void bestDistance(node *, int, int, vector<int> &, vector<int> &, vector<int> &);

bool notExist(vector<int> &, int);

bool satisfy(vector<int> &, vector<int> &);

int find(set<int> &, int);

int main() {
    cin >> n;
    set<int> id;
    int *x = new int[n];
    int *y = new int[n];
    int *z = new int[n];

    for (int i = 0; i < n; i++) {
        cin >> x[i] >> y[i] >> z[i];
        id.insert(x[i]);
        id.insert(y[i]);
    }

    num = id.size();
    mapDef map;
    for (int i = 0; i < n; i++) {
        int idx1 = find(id, x[i]);
        int idx2 = find(id, y[i]);
        map.graph[idx1].dest.push_back(idx2);
        map.graph[idx2].dest.push_back(idx1);
        map.graph[idx1].d.push_back(z[i]);
        map.graph[idx2].d.push_back(z[i]);
    }

    int a, b;
    cin >> a >> b;
    map.begin = find(id, a);
    map.end = find(id, b);
    if (map.begin == map.end) {
        equalFlag = true;
        flag = 1;
    } else
        map.D[map.begin] = 0;

    int go;
    while (cin >> go)
        map.mustGo.push_back(find(id, go));

    bestDistance(map.graph, map.begin, map.end, map.D, map.visited, map.mustGo);
    if (map.D[map.end] == INT_MAX)
        cout << -1 << endl;
    else
        cout << map.D[map.end] << endl;
}

//algorithm
void bestDistance(node *graph, int begin, int end, vector<int> &D, vector<int> &visited, vector<int> &mustGo) {
    visited.push_back(begin);
    if (begin != end || flag == 1) {
        flag = 0;
        for (int idx = 0; idx < graph[begin].dest.size(); idx++)
            if (notExist(visited, graph[begin].dest[idx])) {
                if (graph[begin].dest[idx] == end && satisfy(mustGo, visited) == false)
                    continue;
                D[graph[begin].dest[idx]] = min(D[graph[begin].dest[idx]],
                                                D[begin] == INT_MAX ? graph[begin].d[idx] : D[begin] +
                                                                                            graph[begin].d[idx]);
                bestDistance(graph, graph[begin].dest[idx], end, D, visited, mustGo);
                if (graph[begin].dest[idx] != end)
                    D[graph[begin].dest[idx]] = INT_MAX;
            }
    }
    visited.pop_back();
}

bool notExist(vector<int> &visited, int j) {
    if (equalFlag == false) {
        for (auto i:visited)
            if (i == j)
                return false;
        return true;
    } else {
        if (visited[0] == j) {
            int count = 0;
            for (auto i:visited)
                if (i == visited[0])
                    count++;
            if (count == 1)
                return true;
            else
                return false;
        } else {
            for (auto i:visited)
                if (i == j)
                    return false;
            return true;
        }
    }
}

bool satisfy(vector<int> &x, vector<int> &y) {
    for (auto i:x)
        if (notExist(y, i) == true)
            return false;
    return true;

}

int find(set<int> &id, int x) {
    int idx = -1;
    auto i = id.begin();
    for (; i != id.end(); i++) {
        idx++;
        if (*i == x)
            break;
    }
    return idx;
}
